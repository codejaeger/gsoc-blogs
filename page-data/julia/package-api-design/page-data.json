{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/julia/package-api-design/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Web logs"}},"markdownRemark":{"id":"e4f70c4d-6d4c-56b9-8865-dac2722d2ac5","excerpt":"What is an API? Okay, maybe that’s not why you visited this page, just jump directly to Julia Interfaces . Interfaces Package interfaces Julia packages are…","html":"<h3>What is an API?</h3>\n<p>Okay, maybe that’s not why you visited this page, just jump directly to <a href=\"#julia-interfaces\">Julia Interfaces</a> .</p>\n<h3>Interfaces</h3>\n<h4>Package interfaces</h4>\n<p>Julia packages are defined as a collection of functions, abstract and non-abstract types which are made available (mostly via exports) to any dependent package. It is possible to have packages that just define a few abstract types and a few functions/properties over these abstract types and the user of the package is expected to write their own custom types conforming to the guidelines set by the package. These guidelines ensure that the user’s custom types are usable with the functions supplied by the package and only the smallest subsection of code that must be user defined is allowed to be exposed. You might already guess the advantage behind this, yes lesser chances of bugs getting introduced just because the user forgot to read the docs properly. </p>\n<p>The package we consider for our discussion is :- <a href=\"https://github.com/JuliaGraphs/NetworkLayout.jl\">NetworkLayouts.jl</a>. In fact this article was inspired by unique way the API for this package was designed.</p>\n<p>Before that let’s consider a simpler example.</p>\n<p>Let’s say we have a <code class=\"language-text\">struct</code> called <code class=\"language-text\">Ball</code> and you want this ball to be usable by a package which defines useful utilites for ball type objects. For all we know this could just be a coloring function for the ball. However, this coloring function would not be able to color our ball if it did not know the shape of the ball. So what the package creator could do is define a <code class=\"language-text\">shape</code> function on a abstract type which our ball must be a sub type of. Now, we can provide our own function as part of our user code to support the <code class=\"language-text\">shape</code> call made by the package coloring function. Thus we have successfully, restricted the user to just define a shape function and call it from our package code whenever necessary.</p>\n<p>A simple code example for this would be</p>\n<div class=\"gatsby-highlight\" data-language=\"julia\"><pre class=\"language-julia\"><code class=\"language-julia\"><span class=\"token comment\"># Inside the coloring package</span>\n\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">type</span> BallLike <span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">function</span> coloring<span class=\"token punctuation\">(</span>bl<span class=\"token punctuation\">::</span>BallLike<span class=\"token punctuation\">)</span>\n    shp <span class=\"token operator\">=</span> shape<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># add coloring</span>\n<span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">function</span> shape<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">::</span>A<span class=\"token punctuation\">)</span> <span class=\"token keyword\">end</span>\n\n<span class=\"token comment\"># package code ends here</span>\n<span class=\"token comment\"># user code below</span>\n\n<span class=\"token keyword\">struct</span> Ball <span class=\"token operator\">&lt;:</span> BallLike\n<span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">function</span> shape<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">::</span>Ball<span class=\"token punctuation\">)</span> \n    <span class=\"token comment\"># return shape</span>\n<span class=\"token keyword\">end</span>\n\nb <span class=\"token operator\">=</span> B<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncoloring<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span></code></pre></div>\n<h4>Julia interfaces</h4>\n<p>To look at the actual page in the julia developer manuals, refer to the following <a href=\"https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration\">link</a>. In short, Julia interfaces are a informal collection of functions which when supported (by your type) can unlock a wide suite of convenient functions. </p>\n<p>If you took a glance at the link above, you might notice that interfaces are very popular when it comes to adding support for iteration, indexing, broadcasting etc. for your package. These interfaces are decided by Julia <code class=\"language-text\">Base</code> and are arguably minimal to enable a whole lot of features for your package.</p>\n<h6>A dummy package inspired from NetworkLayout.jl</h6>\n<p>In a few words, this package is required in case you have a graph (or a adjacent matrix) and you wish to create a 2D representation of your graph. There are many options that this package provides to do so but we will not discuss that in this article. Our focus will be on the way the package was designed to make the addition of new network implementations as flexible as possible.</p>\n<p>If we start to look into the module file, we will notice it defines a couple of abstract types and subtypes defined on them. We will also see some macros and functors (functions attached to a type).</p>\n<p>Let’s start by identifying what entails when we add a abstract type to a package. It means that we can define funtions with arguments of that type, attach functions to that type, create new abstract or non-abstract sub-types from that type or simply new types aggregating over that type.\nWhew! that’s a lot. </p>\n<div class=\"gatsby-highlight\" data-language=\"julia\"><pre class=\"language-julia\"><code class=\"language-julia\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">type</span> A <span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">function</span> forA<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">::</span>A<span class=\"token punctuation\">)</span> <span class=\"token keyword\">end</span>\n\n<span class=\"token punctuation\">(</span>attachedToA<span class=\"token punctuation\">::</span>A<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> someFuncDefinedSomewhere<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">abstract</span> <span class=\"token keyword\">type</span> B <span class=\"token operator\">&lt;:</span> A <span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">struct</span> C <span class=\"token operator\">&lt;:</span> A\n<span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">struct</span> D\n    c<span class=\"token punctuation\">::</span>C\n    a<span class=\"token punctuation\">::</span>A\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>Now, even this might not be enough, we may need to add another of abstract types sub-typed over A. Let’s call it <code class=\"language-text\">subA</code>. This type might have some actual package code implemented for it not like the all-knowing mega type <code class=\"language-text\">A</code>. </p>\n<p>Below, we consider one such use case. Let’s say we want to export a function which requires a user to define only a certain property (or a function) over its custom types. The property we consider below is <strong>iterability</strong> which can be enabled by supporting <code class=\"language-text\">Base.iterate()</code>. </p>\n<div class=\"gatsby-highlight\" data-language=\"julia\"><pre class=\"language-julia\"><code class=\"language-julia\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">type</span> subA <span class=\"token operator\">&lt;:</span> A <span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">function</span> someFunc<span class=\"token punctuation\">(</span>sa<span class=\"token punctuation\">::</span>subA<span class=\"token punctuation\">)</span>\n    iter <span class=\"token operator\">=</span> Base<span class=\"token punctuation\">.</span>iterate<span class=\"token punctuation\">(</span>sa<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># do something useful with iter</span>\n<span class=\"token keyword\">end</span>\n\n<span class=\"token comment\"># user code below</span>\n<span class=\"token keyword\">struct</span> someType <span class=\"token operator\">&lt;:</span> subA\n<span class=\"token keyword\">end</span>\n\n<span class=\"token comment\">#define someType with Base.iterate</span>\n<span class=\"token keyword\">function</span> Base<span class=\"token punctuation\">.</span>iterate<span class=\"token punctuation\">(</span>st<span class=\"token punctuation\">::</span>someType<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">#do something</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<!-- ##### Are we done?\n\nWell no, unless we export `someFunc` noone can really use it outside of our package. So what do we do? Note that exporting `someFunc(::subA)` is useless since `subA` is an abstract type. We need to export the `someFunc` method (overloads in julia) defined over the user type `someType`. The problem is we don't know this type unless we let the user use the package which almost always happens after we have published the package. \n\n##### Macros to our rescue!\nOne of my favorite part of Julia is this beast called macro. They let you add code which can modify or create new code! How cool is that?!\n\nWe need to create only one macro for the user to use when they are defining their package. Let's call it `@addcall` (inspired from NetworksLayout.jl). If you are new to macros, reading up the developer manuals is the best place to know more about it.\n\n```julia\nmacro addcall(expr::Expr)\n    typedef = expr.args[2]\n    name = typedef.args[1]\n    fname = Symbol(lowercase(String(name)))\n    return quote\n        $(esc(expr))\n        $(esc(fname))(g; kwargs...) = ($name(; kwargs...), g)\n        export $(esc(fname))\n    end\nend\n```\n\nNow, we can export `@addcall` and let the user use it on their `struct` as follows\n```julia\n@addcall struct someType <: subA\nend\n```\nThis should automatically create and export `someFunc(::someType)` for anybody to use. Yes, now we are done! -->\n<p>Bravo! we have succesfully created a package that can define a very high level interface for users to extend to their free will without the possibility of many bugs getting added.</p>","frontmatter":{"title":"API design: Using Julia interfaces","date":"April 16, 2022","description":"A good API a package keeps the debugger away."}},"previous":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"Introduction and Purpose"}},"next":null},"pageContext":{"id":"e4f70c4d-6d4c-56b9-8865-dac2722d2ac5","previousPostId":"fa1b00ec-5e20-5d0c-816a-de3c06502125","nextPostId":null}},
    "staticQueryHashes": ["2841359383","3257411868"]}